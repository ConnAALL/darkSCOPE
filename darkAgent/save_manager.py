#!/usr/bin/env python3
"""
Save scenario manager for Dark Souls: Remastered â€” containerized and supports multiple simultaneously running instances.

This tool manages swapping of the `DRAKS0005.sl2` save file between:
- Scenario saves shipped in the repository: `darkAgent/dsr_save_files/<scenario>/DRAKS0005.sl2`
- The currently active save directory for a specific Wine prefix or game instance.

For multi-instance setups, use `--instance dsr-X`. This determines the proper save location using `/root/config/dsr_instances.json` (generated by `/root/scripts/generate_config.py`).

CLI commands:
- `list`    : Show all available scenario saves.
- `paths`   : Output all resolved save paths for the given instance.
- `load X`  : Replace the active save with scenario `X` (optionally backing up current save).
- `dump X`  : Copy the current active save into a new scenario folder named `X`.
- `backup`  : Back up the current active save to `darkAgent/dsr_save_files/backups/`.

Examples:
- List all scenarios:
    python3 /root/darkAgent/save_manager.py list
- Print save paths for a given instance:
    python3 /root/darkAgent/save_manager.py --instance dsr-1 paths
- Load a scenario into an instance:
    python3 /root/darkAgent/save_manager.py --instance dsr-3 load asylum_demon
- Dump active save as a new scenario:
    python3 /root/darkAgent/save_manager.py --instance dsr-2 dump my_new_scenario
- Back up the current active save:
    python3 /root/darkAgent/save_manager.py --instance dsr-1 backup
"""

from __future__ import annotations

import argparse
import os
import re
import shutil
import sys
import time
from dataclasses import dataclass
from pathlib import Path

from instance_config import CONFIG_PATH, resolve_instance


SL2_NAME = "DRAKS0005.sl2"  # Default save file nmae 
ID_DIR_RE = re.compile(r"^[0-9]+$")  # Regular expression to match the numeric ID directory


def _now_stamp() -> str:
    """Helper function to get the current timestamp in the format of YYYYMMDD-HHMMSS"""
    return time.strftime("%Y%m%d-%H%M%S")


def _repo_default_scenarios_dir() -> Path:
    """Helper function to get the default scenarios directory"""
    return Path(__file__).resolve().parent / "dsr_save_files"


@dataclass(frozen=True)
class SavePaths:
    """Class to store the save paths"""
    wineprefix: Path
    save_root: Path
    user_id: str
    save_dir: Path


def _resolve_save_paths_from_instance(instance_name: str) -> SavePaths:
    """
    Resolve save paths for a specific instance from /root/config/dsr_instances.json.
    Expects generate_config.py to have populated dsr_user_id + dsr_save_dir (or dsr_save_root).
    """
    inst_cfg = resolve_instance(instance_name)
    dsr_save_dir = inst_cfg.dsr_save_dir
    dsr_save_root = inst_cfg.dsr_save_root
    dsr_user_id = inst_cfg.dsr_user_id
    wineprefix = inst_cfg.wineprefix

    if isinstance(dsr_save_dir, str) and dsr_save_dir.strip():
        save_dir_p = Path(dsr_save_dir).expanduser()
        save_root_p = save_dir_p.parent
        user_id = save_dir_p.name
    else:
        if not (isinstance(dsr_user_id, str) and dsr_user_id.isdigit()):
            raise RuntimeError(f"Instance '{instance_name}' missing 'dsr_save_dir' and valid 'dsr_user_id' in {CONFIG_PATH}")
        user_id = dsr_user_id

        if isinstance(dsr_save_root, str) and dsr_save_root.strip():
            save_root_p = Path(dsr_save_root).expanduser()
        elif isinstance(wineprefix, str) and wineprefix.strip():
            save_root_p = Path(wineprefix).expanduser() / "drive_c/users/root/Documents/NBGI/DARK SOULS REMASTERED"
        else:
            raise RuntimeError(f"Instance '{instance_name}' missing 'dsr_save_root'/'wineprefix' in {CONFIG_PATH}")

        save_dir_p = save_root_p / user_id

    wineprefix_p = Path(wineprefix).expanduser() if isinstance(wineprefix, str) and wineprefix.strip() else Path(os.environ.get("WINEPREFIX", "/opt/prefix")).expanduser()

    if not save_dir_p.is_dir():
        raise RuntimeError(f"Resolved save directory does not exist for instance '{instance_name}': {save_dir_p}")

    return SavePaths(wineprefix=wineprefix_p, save_root=save_root_p, user_id=user_id, save_dir=save_dir_p)


def resolve_save_paths(wineprefix: str | None = None, save_root: str | None = None, user_id: str | None = None, instance: str | None = None) -> SavePaths:
    """
    Helper function to resolve the save paths from the environment variables or the command line arguments.
    
    Args:
        wineprefix: The Wine prefix directory
        save_root: The save root directory
        user_id: The user ID directory
        instance: Instance name from /root/config/dsr_instances.json (preferred when running multi-instance)
    """
    if instance is not None:
        return _resolve_save_paths_from_instance(instance)

    wineprefix_p = Path(wineprefix or os.environ.get("WINEPREFIX", "/opt/prefix")).expanduser()
    env_save_root = os.environ.get("DSR_SAVE_ROOT")
    env_save_dir = os.environ.get("DSR_SAVE_DIR")
    env_user_id = os.environ.get("DSR_USER_ID")

    if save_root:
        save_root_p = Path(save_root).expanduser()
    elif env_save_root:
        save_root_p = Path(env_save_root).expanduser()
    elif env_save_dir:
        save_root_p = Path(env_save_dir).expanduser().parent
    else:
        # Default save root directory is the Wine prefix directory if none of the variables are set: / drive_c/users/root/Documents/NBGI/DARK SOULS REMASTERED
        save_root_p = wineprefix_p / "drive_c/users/root/Documents/NBGI/DARK SOULS REMASTERED"

    if user_id is None:  # If user_id is not set, use the environment variable
        user_id = env_user_id

    if user_id is None:  # If user_id is not set in the environment variables, check if the save root directory exists
        if not save_root_p.exists():
            raise RuntimeError(f"Save root does not exist: {save_root_p}\nIf you are inside the container, run it once (entrypoint will create it),\nor set DSR_SAVE_ROOT / DSR_SAVE_DIR / DSR_USER_ID.")
        ids = sorted([p.name for p in save_root_p.iterdir() if p.is_dir() and ID_DIR_RE.match(p.name)])
        if not ids:
            raise RuntimeError(f"No numeric DSR ID folder found under: {save_root_p}\nTip: start the game once so it generates the ID folder.")
        user_id = ids[0]

    save_dir_p = save_root_p / user_id
    if not save_dir_p.is_dir():
        raise RuntimeError(f"Resolved save directory does not exist: {save_dir_p}")

    return SavePaths(wineprefix=wineprefix_p, save_root=save_root_p, user_id=user_id, save_dir=save_dir_p)


def list_scenarios(scenarios_dir: Path) -> list[str]:
    """Helper function to list the scenarios in the scenarios directory"""
    if not scenarios_dir.exists():
        # If the scenarios directory does not exist, return an empty list
        return []
    out: list[str] = []  # List to store the scenarios
    for p in sorted(scenarios_dir.iterdir()):
        if not p.is_dir():
            continue
        if (p / SL2_NAME).is_file():  # If the scenario directory contains the save file, add the scenario name to the list
            out.append(p.name)
    return out


def _assert_scenario_exists(scenarios_dir: Path, scenario: str) -> Path:
    """Helper function to check if the requested scenario exists"""
    scenario_dir = scenarios_dir / scenario
    if not scenario_dir.is_dir():
        available = list_scenarios(scenarios_dir)
        raise RuntimeError(f"Unknown scenario '{scenario}'.\nScenarios dir: {scenarios_dir}\nAvailable: {', '.join(available) if available else '(none found)'}")
    sl2 = scenario_dir / SL2_NAME
    if not sl2.is_file():
        raise RuntimeError(f"Scenario folder is missing {SL2_NAME}: {scenario_dir}")
    return sl2


def backup_current_save(paths: SavePaths, backup_root: Path) -> Path | None:
    """Helper function to backup the current save into the backup directory"""
    src = paths.save_dir / SL2_NAME
    if not src.is_file():
        return None
    dst_dir = backup_root / "backups" / f"{_now_stamp()}_{paths.user_id}"
    dst_dir.mkdir(parents=True, exist_ok=True)
    dst = dst_dir / SL2_NAME
    shutil.copy2(src, dst)
    return dst


def load_scenario(paths: SavePaths, scenarios_dir: Path, scenario: str, backup: bool, wipe_sl2: bool) -> None:
    """Helper function to load a scenario into the active save directory"""
    src = _assert_scenario_exists(scenarios_dir, scenario)
    dst = paths.save_dir / SL2_NAME

    if backup:
        backed_up = backup_current_save(paths, scenarios_dir)
        if backed_up:
            print(f"[save] backed up current save to: {backed_up}")

    if wipe_sl2 and dst.exists():
        dst.unlink()

    dst.parent.mkdir(parents=True, exist_ok=True)
    shutil.copy2(src, dst)
    print(f"[save] loaded scenario '{scenario}' -> {dst}")


def dump_current(paths: SavePaths, scenarios_dir: Path, name: str, overwrite: bool) -> None:
    """Helper function to dump the current active save into a new scenario folder"""
    src = paths.save_dir / SL2_NAME
    if not src.is_file():
        raise RuntimeError(f"No current save file found at: {src}")

    dst_dir = scenarios_dir / name
    dst = dst_dir / SL2_NAME

    if dst.exists() and not overwrite:
        raise RuntimeError(f"Destination already exists: {dst} (use --overwrite)")

    dst_dir.mkdir(parents=True, exist_ok=True)
    shutil.copy2(src, dst)
    print(f"[save] dumped current save -> scenario '{name}': {dst}")


def main(argv: list[str]) -> int:
    p = argparse.ArgumentParser(prog="save_manager.py", description="Manage Dark Souls Remastered save swapping inside the container.")
    p.add_argument("--instance", help="Target instance name from /root/config/dsr_instances.json (required for paths/load/dump/backup).")
    sub = p.add_subparsers(dest="cmd", required=True)
    sub.add_parser("paths", help="Print resolved save paths (root/id/save_dir)")
    sub.add_parser("list", help="List available scenarios")
    load = sub.add_parser("load", help="Load a scenario into the active save directory")
    
    load.add_argument("scenario", help="Scenario name (folder under scenarios-dir)")
    load.add_argument("--no-backup", action="store_true", help="Do not backup current save before replacing")
    load.add_argument("--no-wipe", action="store_true", help="Do not delete existing DRAKS0005.sl2 before copy")

    dump = sub.add_parser("dump", help="Dump the current active save into a new scenario folder")
    dump.add_argument("name", help="Scenario name to create/update under scenarios-dir")
    dump.add_argument("--overwrite", action="store_true", help="Allow overwriting an existing scenario save")

    backup = sub.add_parser("backup", help="Backup the current active save into scenarios-dir/backups/")

    args = p.parse_args(argv)

    scenarios_dir = _repo_default_scenarios_dir()

    if args.cmd == "list":  # List the scenarios in the scenarios directory
        items = list_scenarios(scenarios_dir)
        for name in items:
            print(name)
        return 0

    if not args.instance:
        p.error("--instance is required for this command")

    paths = resolve_save_paths(instance=args.instance)  # Resolve the save paths

    if args.cmd == "paths":  # Print the save paths
        if args.instance:
            print(f"instance:   {args.instance}")
            print(f"config:     {CONFIG_PATH}")
        print(f"wineprefix: {paths.wineprefix}")
        print(f"save_root:  {paths.save_root}")
        print(f"user_id:    {paths.user_id}")
        print(f"save_dir:   {paths.save_dir}")
        print(f"active_sl2: {paths.save_dir / SL2_NAME}")
        return 0

    if args.cmd == "load":  # Load a scenario into the active save directory
        load_scenario(paths=paths, scenarios_dir=scenarios_dir, scenario=args.scenario, backup=not args.no_backup, wipe_sl2=not args.no_wipe)
        return 0

    if args.cmd == "dump":  # Dump the current active save into a new scenario folder
        dump_current(paths=paths, scenarios_dir=scenarios_dir, name=args.name, overwrite=args.overwrite)
        return 0

    if args.cmd == "backup":  # Backup the current active save into the backup directory
        dst = backup_current_save(paths, scenarios_dir)
        if not dst:
            print(f"[save] nothing to backup (missing {SL2_NAME} in {paths.save_dir})")
            return 0
        print(f"[save] backed up current save to: {dst}")
        return 0

    raise AssertionError("unreachable")


if __name__ == "__main__":
    raise SystemExit(main(sys.argv[1:]))
